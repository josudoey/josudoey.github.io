# Design Pattern Concept

## 創建型模式 (Creational Patterns)

### Factory Method Pattern (工廠方法模式)

提供一個通用的介面來創建物件，但將具體創建哪個物件的職責交由到子類別決定。

- 用途： 當有多種產品有相同介面，但需要不同初始化方式時。
- 範例： 遊戲中根據不同角色類型創建玩家物件。

### Abstract Factory Pattern (抽象工廠模式)

提供一個介面，用於創建一系列相關或相互依賴的物件，而無需指定它們的具體類別。

- 用途： 當你需要生產一整套協同工作且屬於**不同「風格」或「系列」**的產品時。
- 範例： 跨平台 UI 庫（Windows 按鈕/Mac 按鈕），你選擇一個工廠就得到一套特定風格的 UI 元件。

### Singleton Pattern (單例模式)

確保一個類別只有一個實例，並提供一個全局訪問點。

- 用途： 當某個物件只需要一個，且需要被整個系統共享和控制時。
- 範例： 日誌管理器 (Logger)、資料庫連接池。

### Builder Pattern (建造者模式)

將一個複雜物件的建造過程與其表示分離，使得相同的建造過程可以創建不同的表示。

- 用途： 當一個物件的構建過程非常複雜，有多個可選參數或步驟時，避免建構式參數過多。
- 範例： StringBuilder（字串構建器），一步步構建複雜字串；配置物件的複雜構建。

### Prototype Pattern (原型模式)

通過複製現有的物件來創建新物件，而不是通過傳統的建構式。

- 用途： 當創建物件的成本較高，或者你需要創建大量相似但略有不同的物件時。
- 範例： 遊戲中透過複製「原型」怪物來快速生成新怪物；複製複雜的配置物件。

## 結構型模式 (Structural Patterns)

Decorator Pattern (裝飾者模式)
在不修改原始類別程式碼的情況下，動態地為物件添加新功能。

- 用途： 提供靈活地組合功能。
- 範例： Golang 中的 io.Reader 家族

### Adapter Pattern (適配器模式)

將一個類別的介面轉換為客戶端期望的另一個介面。

- 用途： 讓原本不相容的介面能夠協同工作。
- 範例： 舊版程式碼與新版函式庫之間的「兼容適配器」。

### Proxy Pattern (代理模式)

為另一個物件提供一個替身或佔位符，以控制對這個物件的訪問。

- 用途： 提供額外的控制層，如延遲加載、訪問控制、日誌記錄、遠端訪問。
- 範例： RPC（遠端過程呼叫）中的客戶端 Stub/Proxy；物件關係映射 (ORM) 中的延遲加載。

### Composite Pattern (組合模式)

將物件組合成樹狀結構來表示「部分-整體」的層次結構，讓客戶端可以一致地處理單個物件和物件組合。

- 用途： 當你希望統一處理單個物件和物件集合時。
- 範例： HTML DOM 樹；文件系統中的檔案和目錄。

### Bridge Pattern(橋接模式)

將一個物件的抽象層與其實現層分離，使兩者可以獨立變化。

- 用途： 當物件有兩個或多個獨立變化的維度時，避免類別爆炸。
- 範例： Java AWT (Abstract Window Toolkit)，將 UI 元件的抽象與其在不同作業系統上的原生實現分離。

### Facade Pattern (門面模式)

為子系統中的一組介面提供一個統一的、高層次的介面。

- 用途： 簡化複雜子系統的使用，降低客戶端與子系統的耦合。
- 範例： 命令行介面 (CLI) 工具，為複雜的後台操作提供簡單的命令。

### Flyweight Pattern (享元模式)

運用共享技術有效地支持大量細顆粒度的物件。

- 用途： 當你需要創建大量內容重複但實例獨立的物件時，以節省記憶體。
- 範例： 字串池 (String Pool)，重複使用的字串實例指向同一塊記憶體。

## 行為型模式 (Behavioral Patterns)

### Chain of Responsibility Pattern (責任鏈模式)

將請求沿著一條處理者鏈傳遞，直到鏈中的某個物件處理它為止。

- 用途： 將請求的發送者與接收者解耦，允許動態配置處理流程。
- 範例： WSGI Middleware（Python Web 框架），請求通過一系列中介軟體處理。

### Command Pattern (命令模式)

將一個請求封裝成一個物件，從而讓你用不同的請求、隊列或日誌來參數化客戶端。

- 用途： 實現請求的解耦、撤銷/重做、日誌記錄等功能。
- 範例： Undo/Redo 功能，每個操作都被包裝成一個可執行的命令物件。

### Interpreter Pattern (解釋器模式)

為一個語言的文法定義一個解釋器，將文法規則映射到類別結構。

- 用途： 當你需要處理和執行一種**特定領域的「微型語言」**時。
- 範例： 正規表達式 (RegExp) 引擎，解釋模式字串並進行匹配。

### Iterator Pattern (迭代器模式)

提供一種循序存取物件集合中各個元素的方法，而又不需要暴露該物件的內部表示。

- 用途： 統一遍歷不同集合的方式，隱藏集合的內部結構。
- 範例： jQuery 中的集合操作，提供選定的 DOM 元素。

### Mediator Pattern (中介者模式)

用一個中介者物件來封裝一組物件的交互方式，減少它們之間的直接耦合。

- 用途： 當多個物件之間有複雜的網狀通信，且你希望集中控制和簡化這些交互時。
- 範例： WebRTC 信令伺服器，協調兩個對等端之間的連接信息交換。

### Memento Pattern (備忘錄模式)

在不破壞封裝性的前提下，捕捉一個物件的內部狀態，以便該物件可以恢復到先前的狀態。

- 用途： 實現物件的回溯或撤銷功能。
- 範例： 文字編輯器中的 Undo/Redo 功能。

### Observer Pattern (觀察者模式)

定義了一種一對多的依賴關係，當物件的狀態改變，所有依賴於它的物件都會得到通知並被自動更新。

- 用途： 當一個物件的改變需要自動通知其他多個物件時。
- 範例： EventEmitter (事件發射器)，GUI 中按鈕點擊後通知所有監聽器。

### State Pattern (狀態模式)

允許物件在內部狀態改變時改變其行為，物件看起來好像改變了它的類別。

- 用途： 當物件的行為依賴於其內部狀態，並且狀態改變導致行為改變時，避免大量條件判斷。
- 範例： TCP 連接的狀態機（ESTABLISHED, CLOSED 等），不同狀態下對相同事件的響應不同。

### Strategy Pattern (策略模式)

定義一系列的演算法，將每一個演算法封裝起來，並且使它們可以互相替換。

- 用途： 當一個功能有多種執行方法，且需要在運行時動態切換時，避免使用 if-else 或 switch-case。
- 範例： 快取淘汰策略（LRU, FIFO 等），根據需要切換快取演算法。

### Template Method Pattern (模板方法模式)

定義一個操作中的演算法骨架，而將一些步驟延遲到子類別中實現。

- 用途： 當多個子類別的某個操作大部分步驟相同，只有少數步驟不同時。
- 範例： 遊戲的生命週期流程（初始化、循環、結束）或資料處理管道，固定流程但部分細節可變。
